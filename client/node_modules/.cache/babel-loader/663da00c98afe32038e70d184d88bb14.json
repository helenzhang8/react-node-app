{"ast":null,"code":"'use strict';\n\nconst MongoError = require('./core/error').MongoError;\n\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function (obj) {\n  var copy = {};\n\n  for (var name in obj) copy[name] = obj[name];\n\n  return copy;\n}; // Set simple property\n\n\nvar getSingleProperty = function (obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function () {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = exports.formatSortValue = function (sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n\n    default:\n      throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], \" + \"['field2', '(ascending|descending)']]\");\n  }\n};\n\nvar formattedOrderClause = exports.formattedOrderClause = function (sortValue) {\n  var orderBy = new Map();\n  if (sortValue == null) return null;\n\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy.set(`${sortValue[i]}`, 1);\n      } else {\n        orderBy.set(`${sortValue[i][0]}`, formatSortValue(sortValue[i][1]));\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    if (sortValue instanceof Map) {\n      orderBy = sortValue;\n    } else {\n      var sortKeys = Object.keys(sortValue);\n\n      for (var k of sortKeys) {\n        orderBy.set(k, sortValue[k]);\n      }\n    }\n  } else if (typeof sortValue === 'string') {\n    orderBy.set(`${sortValue}`, 1);\n  } else {\n    throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n  }\n\n  return orderBy;\n};\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function (callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\n\n\nvar toError = function (error) {\n  if (error instanceof Error) return error;\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({\n    message: msg,\n    driver: true\n  }); // Get all object keys\n\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {// continue\n    }\n  }\n\n  return e;\n};\n/**\n * @ignore\n */\n\n\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(function (param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\n\n\nvar parseIndexOptions = function (fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys; // Get all the fields accordingly\n\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function (f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function (k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function (key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = exports.isObject = function (arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n};\n\nvar debugOptions = function (debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function (n) {\n    finaloptions[n] = options[n];\n  });\n  return finaloptions;\n};\n\nvar decorateCommand = function (command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function (target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n}; // Merge options with translation\n\n\nvar translateOptions = function (target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function (options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  } // Filtered options\n\n\n  return filterOptions;\n}; // Write concern keys\n\n\nconst WRITE_CONCERN_KEYS = ['w', 'j', 'wtimeout', 'fsync', 'writeConcern'];\n/**\n * If there is no WriteConcern related options defined on target then inherit from source.\n * Otherwise, do not inherit **any** options from source.\n * @internal\n * @param {object} target - options object conditionally receiving the writeConcern options\n * @param {object} source - options object containing the potentially inherited writeConcern options\n */\n\nfunction conditionallyMergeWriteConcern(target, source) {\n  let found = false;\n\n  for (const wcKey of WRITE_CONCERN_KEYS) {\n    if (wcKey in target) {\n      // Found a writeConcern option\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (const wcKey of WRITE_CONCERN_KEYS) {\n      if (source[wcKey]) {\n        if (!('writeConcern' in target)) {\n          target.writeConcern = {};\n        }\n\n        target.writeConcern[wcKey] = source[wcKey];\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\n\n\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1]; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session, opOptions, owner;\n\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], {\n        session: session\n      });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {\n    if (session && session.owner === owner && !options.returnsCursor) {\n      session.endSession(() => {\n        delete opOptions.session;\n        if (err) return reject(err);\n        resolve(result);\n      });\n    } else {\n      if (err) return reject(err);\n      resolve(result);\n    }\n  }; // Execute using callback\n\n\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(result => callback(null, result), err => callback(err, null));\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  } // Return a Promise\n\n\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function (resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\n\n\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\n\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\n\n\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\n\n\nfunction decorateWithCollation(command, target, options) {\n  const topology = target.s && target.s.topology || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\n\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  let readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param {object} command - the command on which to apply the explain\n * @param {Explain} explain - the options containing the explain verbosity\n * @return the new command\n */\n\n\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\n\nconst nodejsMajorVersion = +process.version.split('.')[0].substring(1);\n\nconst emitProcessWarning = msg => nodejsMajorVersion <= 6 ? process.emitWarning(msg, 'DeprecationWarning', MONGODB_WARNING_CODE) : process.emitWarning(msg, {\n  type: 'DeprecationWarning',\n  code: MONGODB_WARNING_CODE\n}); // eslint-disable-next-line no-console\n\n\nconst emitConsoleWarning = msg => console.error(msg);\n\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\n\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\n\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n\n  function deprecated() {\n    const options = arguments[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (Object.prototype.hasOwnProperty.call(options, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n    return fn.apply(this, arguments);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {}; // Test asyncIterator support\n\ntry {\n  require('./async/async_iterator');\n\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n\n}\n\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n/**\n * Helper function for either accepting a callback, or returning a promise\n *\n * @param {Object} parent an instance of parent with promiseLibrary.\n * @param {object} parent.s an object containing promiseLibrary.\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\n * @param {[Function]} callback an optional callback.\n * @param {Function} fn A function that takes a callback\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\n */\n\n\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  fn(function (err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n\n      return;\n    }\n\n    callback(err, res);\n  });\n  return result;\n}\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n *\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\n * @param {object} [options] Optional settings\n * @param {number} [options.interval] The interval at which to run the provided function\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\n */\n\n\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime; // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // debounce multiple calls to wake within the `minInterval`\n\n    if (timeSinceLastWake < minInterval) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    } // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n\n\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule();\n  }\n\n  return {\n    wake,\n    stop\n  };\n}\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    return doc.reduce((err, u) => err || hasAtomicOperators(u), null);\n  }\n\n  return Object.keys(typeof doc.toBSON !== 'function' ? doc : doc.toBSON()).map(k => k[0]).indexOf('$') >= 0;\n}\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\n\n\nconst MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/**\n * @internal\n * @param {string} message - message to warn about\n */\n\nfunction emitWarning(message) {\n  if (process.emitWarning) {\n    return nodejsMajorVersion <= 6 ? process.emitWarning(message, undefined, MONGODB_WARNING_CODE) : process.emitWarning(message, {\n      code: MONGODB_WARNING_CODE\n    });\n  } else {\n    // Approximate the style of print out on node versions pre 8.x\n    // eslint-disable-next-line no-console\n    return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);\n  }\n}\n\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n * @param {string} message - message to warn about\n */\n\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  conditionallyMergeWriteConcern,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  decorateWithExplain,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval,\n  hasAtomicOperators,\n  MONGODB_WARNING_CODE,\n  emitWarning,\n  emitWarningOnce\n};","map":{"version":3,"sources":["/Users/helenzhang/Desktop/Summer 2021/Basil/react-node-app/client/node_modules/mongodb/lib/utils.js"],"names":["MongoError","require","WriteConcern","shallowClone","obj","copy","name","getSingleProperty","value","Object","defineProperty","enumerable","get","formatSortValue","exports","sortDirection","toLowerCase","Error","formattedOrderClause","sortValue","orderBy","Map","Array","isArray","length","i","constructor","String","set","sortKeys","keys","k","checkCollectionName","collectionName","indexOf","match","handleCallback","callback","err","value1","value2","process","nextTick","toError","error","msg","errmsg","errMessage","e","create","message","driver","normalizeHintField","hint","finalHint","forEach","param","parseIndexOptions","fieldOrSpec","fieldHash","indexes","push","f","isObject","key","join","arg","prototype","toString","call","debugOptions","debugFields","options","finaloptions","n","decorateCommand","command","exclude","mergeOptions","target","source","translateOptions","translations","sslCA","sslCRL","sslValidate","sslKey","sslCert","sslPass","socketTimeoutMS","connectTimeoutMS","replicaSet","rs_name","secondaryAcceptableLatencyMS","connectWithNoPrimary","acceptableLatencyMS","filterOptions","names","WRITE_CONCERN_KEYS","conditionallyMergeWriteConcern","found","wcKey","writeConcern","executeLegacyOperation","topology","operation","args","TypeError","Promise","s","promiseLibrary","session","opOptions","owner","skipSessions","hasSessionSupport","Symbol","startSession","optionsIndex","assign","hasEnded","makeExecuteCallback","resolve","reject","executeCallback","result","returnsCursor","endSession","pop","handler","apply","applyRetryableWrites","db","retryWrites","applyWriteConcern","sources","coll","collection","inTransaction","fromOptions","isPromiseLike","maybePromise","then","decorateWithCollation","capabilities","collation","commandsTakeCollation","decorateWithReadConcern","readConcern","decorateWithExplain","explain","verbosity","nodejsMajorVersion","version","split","substring","emitProcessWarning","emitWarning","MONGODB_WARNING_CODE","type","code","emitConsoleWarning","console","emitDeprecationWarning","defaultMsgHandler","option","deprecateOptions","config","fn","noDeprecation","msgHandler","optionsWarned","Set","deprecated","arguments","deprecatedOptions","deprecatedOption","hasOwnProperty","has","add","getLogger","logger","warn","setPrototypeOf","SUPPORTS","ASYNC_ITERATOR","MongoDBNamespace","withCollection","fromString","namespace","index","makeCounter","seed","count","newCount","parent","PromiseLibrary","res","now","hrtime","Math","floor","calculateDurationInMs","started","elapsed","makeInterruptableAsyncInterval","timerId","lastCallTime","lastWakeTime","stopped","interval","minInterval","immediate","clock","wake","currentTime","timeSinceLastWake","timeSinceLastCall","timeUntilNextCall","reschedule","executeAndReschedule","stop","clearTimeout","ms","setTimeout","hasAtomicOperators","doc","reduce","u","toBSON","map","undefined","emittedWarnings","emitWarningOnce","module","MAX_JS_INT","Number","MAX_SAFE_INTEGER"],"mappings":"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","sourcesContent":["'use strict';\nconst MongoError = require('./core/error').MongoError;\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function(obj) {\n  var copy = {};\n  for (var name in obj) copy[name] = obj[name];\n  return copy;\n};\n\n// Set simple property\nvar getSingleProperty = function(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function() {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = (exports.formatSortValue = function(sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new Error(\n        'Illegal sort clause, must be of the form ' +\n          \"[['field1', '(ascending|descending)'], \" +\n          \"['field2', '(ascending|descending)']]\"\n      );\n  }\n});\n\nvar formattedOrderClause = (exports.formattedOrderClause = function(sortValue) {\n  var orderBy = new Map();\n  if (sortValue == null) return null;\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy.set(`${sortValue[i]}`, 1);\n      } else {\n        orderBy.set(`${sortValue[i][0]}`, formatSortValue(sortValue[i][1]));\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    if (sortValue instanceof Map) {\n      orderBy = sortValue;\n    } else {\n      var sortKeys = Object.keys(sortValue);\n      for (var k of sortKeys) {\n        orderBy.set(k, sortValue[k]);\n      }\n    }\n  } else if (typeof sortValue === 'string') {\n    orderBy.set(`${sortValue}`, 1);\n  } else {\n    throw new Error(\n      'Illegal sort clause, must be of the form ' +\n        \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\"\n    );\n  }\n\n  return orderBy;\n});\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (\n    collectionName.indexOf('$') !== -1 &&\n    collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null\n  ) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  }\n\n  // Validate that we are not passing 0x00 in the collection name\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function(callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function() {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\nvar toError = function(error) {\n  if (error instanceof Error) return error;\n\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({ message: msg, driver: true });\n\n  // Get all object keys\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {\n      // continue\n    }\n  }\n\n  return e;\n};\n\n/**\n * @ignore\n */\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n\n    hint.forEach(function(param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\nvar parseIndexOptions = function(fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys;\n\n  // Get all the fields accordingly\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function(f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function(k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {\n        // undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function(key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = (exports.isObject = function(arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n});\n\nvar debugOptions = function(debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function(n) {\n    finaloptions[n] = options[n];\n  });\n\n  return finaloptions;\n};\n\nvar decorateCommand = function(command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function(target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n};\n\n// Merge options with translation\nvar translateOptions = function(target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function(options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  }\n\n  // Filtered options\n  return filterOptions;\n};\n\n// Write concern keys\nconst WRITE_CONCERN_KEYS = ['w', 'j', 'wtimeout', 'fsync', 'writeConcern'];\n\n/**\n * If there is no WriteConcern related options defined on target then inherit from source.\n * Otherwise, do not inherit **any** options from source.\n * @internal\n * @param {object} target - options object conditionally receiving the writeConcern options\n * @param {object} source - options object containing the potentially inherited writeConcern options\n */\nfunction conditionallyMergeWriteConcern(target, source) {\n  let found = false;\n  for (const wcKey of WRITE_CONCERN_KEYS) {\n    if (wcKey in target) {\n      // Found a writeConcern option\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (const wcKey of WRITE_CONCERN_KEYS) {\n      if (source[wcKey]) {\n        if (!('writeConcern' in target)) {\n          target.writeConcern = {};\n        }\n        target.writeConcern[wcKey] = source[wcKey];\n      }\n    }\n  }\n\n  return target;\n}\n\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1];\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session, opOptions, owner;\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({ owner });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], { session: session });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) =>\n    function executeCallback(err, result) {\n      if (session && session.owner === owner && !options.returnsCursor) {\n        session.endSession(() => {\n          delete opOptions.session;\n          if (err) return reject(err);\n          resolve(result);\n        });\n      } else {\n        if (err) return reject(err);\n        resolve(result);\n      }\n    };\n\n  // Execute using callback\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(\n      result => callback(null, result),\n      err => callback(err, null)\n    );\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  }\n\n  // Return a Promise\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function(resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n  if (writeConcern) {\n    return Object.assign(target, { writeConcern });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\n  }\n\n  return target;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n  const topology = (target.s && target.s.topology) || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  let readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, { readConcern: readConcern });\n  }\n}\n\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param {object} command - the command on which to apply the explain\n * @param {Explain} explain - the options containing the explain verbosity\n * @return the new command\n */\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return { explain: command, verbosity: explain.verbosity };\n}\n\nconst nodejsMajorVersion = +process.version.split('.')[0].substring(1);\nconst emitProcessWarning = msg =>\n  nodejsMajorVersion <= 6\n    ? process.emitWarning(msg, 'DeprecationWarning', MONGODB_WARNING_CODE)\n    : process.emitWarning(msg, { type: 'DeprecationWarning', code: MONGODB_WARNING_CODE });\n// eslint-disable-next-line no-console\nconst emitConsoleWarning = msg => console.error(msg);\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n\n  const optionsWarned = new Set();\n  function deprecated() {\n    const options = arguments[config.optionsIndex];\n\n    // ensure options is a valid, non-empty object, otherwise short-circuit\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (\n        Object.prototype.hasOwnProperty.call(options, deprecatedOption) &&\n        !optionsWarned.has(deprecatedOption)\n      ) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n\n    return fn.apply(this, arguments);\n  }\n\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {};\n// Test asyncIterator support\ntry {\n  require('./async/async_iterator');\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n}\n\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\n/**\n * Helper function for either accepting a callback, or returning a promise\n *\n * @param {Object} parent an instance of parent with promiseLibrary.\n * @param {object} parent.s an object containing promiseLibrary.\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\n * @param {[Function]} callback an optional callback.\n * @param {Function} fn A function that takes a callback\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\n */\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = (parent && parent.s && parent.s.promiseLibrary) || Promise;\n\n  let result;\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  fn(function(err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n      return;\n    }\n\n    callback(err, res);\n  });\n\n  return result;\n}\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n *\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\n * @param {object} [options] Optional settings\n * @param {number} [options.interval] The interval at which to run the provided function\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\n */\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime;\n\n    // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n\n    // debounce multiple calls to wake within the `minInterval`\n    if (timeSinceLastWake < minInterval) {\n      return;\n    }\n\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    }\n\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule();\n  }\n\n  return { wake, stop };\n}\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    return doc.reduce((err, u) => err || hasAtomicOperators(u), null);\n  }\n\n  return (\n    Object.keys(typeof doc.toBSON !== 'function' ? doc : doc.toBSON())\n      .map(k => k[0])\n      .indexOf('$') >= 0\n  );\n}\n\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nconst MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n\n/**\n * @internal\n * @param {string} message - message to warn about\n */\nfunction emitWarning(message) {\n  if (process.emitWarning) {\n    return nodejsMajorVersion <= 6\n      ? process.emitWarning(message, undefined, MONGODB_WARNING_CODE)\n      : process.emitWarning(message, { code: MONGODB_WARNING_CODE });\n  } else {\n    // Approximate the style of print out on node versions pre 8.x\n    // eslint-disable-next-line no-console\n    return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);\n  }\n}\n\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n * @param {string} message - message to warn about\n */\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  conditionallyMergeWriteConcern,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  decorateWithExplain,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval,\n  hasAtomicOperators,\n  MONGODB_WARNING_CODE,\n  emitWarning,\n  emitWarningOnce\n};\n"]},"metadata":{},"sourceType":"script"}