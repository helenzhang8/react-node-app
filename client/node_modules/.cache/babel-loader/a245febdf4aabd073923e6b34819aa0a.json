{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst MessageStream = require('./message_stream');\n\nconst MongoError = require('../core/error').MongoError;\n\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\n\nconst MongoNetworkTimeoutError = require('../core/error').MongoNetworkTimeoutError;\n\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\n\nconst CommandResult = require('../core/connection/command_result');\n\nconst StreamDescription = require('./stream_description').StreamDescription;\n\nconst wp = require('../core/wireprotocol');\n\nconst apm = require('../core/connection/apm');\n\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\n\nconst uuidV4 = require('../core/utils').uuidV4;\n\nconst now = require('../utils').now;\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    this.host = options.host || 'localhost';\n    this.port = options.port || 27017;\n    this.monitorCommands = typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now(); // retain a reference to an `AutoEncrypter` if present\n\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    } // setup parser stream and message handling\n\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    this[kMessageStream].on('error', error => this.handleIssue({\n      destroy: error\n    }));\n    stream.on('close', () => this.handleIssue({\n      isClose: true\n    }));\n    stream.on('timeout', () => this.handleIssue({\n      isTimeout: true,\n      destroy: true\n    })); // hook the message stream up to the passed in stream\n\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  } // the `connect` method stores the result of the handshake ismaster on the connection\n\n\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kIsMaster] = response;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime() {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = now();\n  }\n  /**\n   * @param {{ isTimeout?: boolean; isClose?: boolean; destroy?: boolean | Error }} issue\n   */\n\n\n  handleIssue(issue) {\n    if (this.closed) {\n      return;\n    }\n\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n\n    this.closed = true;\n\n    for (const idAndOp of this[kQueue]) {\n      const op = idAndOp[1];\n\n      if (issue.isTimeout) {\n        op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n          beforeHandshake: this.ismaster == null\n        }));\n      } else if (issue.isClose) {\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n\n    this[kQueue].clear();\n    this.emit('close');\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(err => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  } // Wire protocol methods\n\n\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n} /// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\n\n\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: {\n        write: write.bind(connection),\n        isConnected: () => true\n      }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    const callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    conn[kQueue].delete(message.responseTo);\n\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    } // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n\n    callback(undefined, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n} // Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\n\n\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operationDescription.started = now();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit('commandFailed', new apm.CommandFailedEvent(this, command, err, operationDescription.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit('commandFailed', new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));\n        } else {\n          this.emit('commandSucceeded', new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection\n};","map":{"version":3,"sources":["/Users/helenzhang/Desktop/Summer 2021/Basil/react-node-app/client/node_modules/mongodb/lib/cmap/connection.js"],"names":["EventEmitter","require","MessageStream","MongoError","MongoNetworkError","MongoNetworkTimeoutError","MongoWriteConcernError","CommandResult","StreamDescription","wp","apm","updateSessionFromResponse","uuidV4","now","calculateDurationInMs","kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kIsMaster","kAutoEncrypter","Connection","constructor","stream","options","id","address","streamIdentifier","bson","socketTimeout","host","port","monitorCommands","closed","destroyed","generation","autoEncrypter","Map","on","messageHandler","error","handleIssue","destroy","isClose","isTimeout","pipe","description","ismaster","response","receiveResponse","idleTime","clusterTime","markAvailable","issue","undefined","idAndOp","op","cb","beforeHandshake","clear","emit","callback","Object","assign","force","end","err","command","ns","cmd","makeServerTrampoline","query","cursorState","getMore","batchSize","killCursors","insert","ops","update","remove","connection","server","s","pool","write","bind","isConnected","conn","message","has","responseTo","operationDescription","get","delete","moreToCome","set","requestId","socketTimeoutOverride","setTimeout","parse","documents","document","session","$clusterTime","writeConcernError","ok","$err","errmsg","code","fullResult","remoteAddress","remotePort","toString","noResponse","documentsReturnedIn","promoteLongs","promoteValues","promoteBuffers","raw","compressor","agreedCompressor","zlibCompressionLevel","CommandStartedEvent","started","reply","CommandFailedEvent","result","CommandSucceededEvent","writeCommand","e","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst MessageStream = require('./message_stream');\nconst MongoError = require('../core/error').MongoError;\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../core/error').MongoNetworkTimeoutError;\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\nconst CommandResult = require('../core/connection/command_result');\nconst StreamDescription = require('./stream_description').StreamDescription;\nconst wp = require('../core/wireprotocol');\nconst apm = require('../core/connection/apm');\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\nconst uuidV4 = require('../core/utils').uuidV4;\nconst now = require('../utils').now;\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    this.host = options.host || 'localhost';\n    this.port = options.port || 27017;\n    this.monitorCommands =\n      typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // retain a reference to an `AutoEncrypter` if present\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    }\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    this[kMessageStream].on('error', error => this.handleIssue({ destroy: error }));\n    stream.on('close', () => this.handleIssue({ isClose: true }));\n    stream.on('timeout', () => this.handleIssue({ isTimeout: true, destroy: true }));\n\n    // hook the message stream up to the passed in stream\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  }\n\n  // the `connect` method stores the result of the handshake ismaster on the connection\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kIsMaster] = response;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime() {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = now();\n  }\n\n  /**\n   * @param {{ isTimeout?: boolean; isClose?: boolean; destroy?: boolean | Error }} issue\n   */\n  handleIssue(issue) {\n    if (this.closed) {\n      return;\n    }\n\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n\n    this.closed = true;\n\n    for (const idAndOp of this[kQueue]) {\n      const op = idAndOp[1];\n      if (issue.isTimeout) {\n        op.cb(\n          new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n            beforeHandshake: this.ismaster == null\n          })\n        );\n      } else if (issue.isClose) {\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n\n    this[kQueue].clear();\n    this.emit('close');\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  // Wire protocol methods\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n}\n\n/// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: { write: write.bind(connection), isConnected: () => true }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    conn[kQueue].delete(message.responseTo);\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    }\n\n    // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n    callback(\n      undefined,\n      new CommandResult(\n        operationDescription.fullResult ? message : message.documents[0],\n        conn,\n        message\n      )\n    );\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n}\n\n// Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit(\n          'commandFailed',\n          new apm.CommandFailedEvent(this, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit(\n            'commandFailed',\n            new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started)\n          );\n        } else {\n          this.emit(\n            'commandSucceeded',\n            new apm.CommandSucceededEvent(this, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection\n};\n"]},"metadata":{},"sourceType":"script"}